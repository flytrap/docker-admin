# Patroni-Stack 单节点编排
# 每台物理机部署一份，通过 .env 区分 NODE_ID / NODE_IP
# 包含：etcd、patroni、haproxy、pgbouncer、keepalived

networks:
  pg-net:
    driver: bridge

services:
  etcd:
    image: ${PATRONI_IMAGE:-patroni:v4.1.0.1}
    container_name: etcd
    hostname: etcd${NODE_ID}
    environment:
      ETCD_NAME: etcd${NODE_ID}
      ETCD_DATA_DIR: /etcd-data
      ETCD_LISTEN_PEER_URLS: http://0.0.0.0:2380
      ETCD_LISTEN_CLIENT_URLS: http://0.0.0.0:2379
      ETCD_ADVERTISE_CLIENT_URLS: http://${NODE_IP}:2379
      ETCD_INITIAL_ADVERTISE_PEER_URLS: http://${NODE_IP}:2380
      ETCD_INITIAL_CLUSTER: ${ETCD_INITIAL_CLUSTER:-etcd1=http://${NODE1_IP}:2380,etcd2=http://${NODE2_IP}:2380,etcd3=http://${NODE3_IP}:2380}
      ETCD_INITIAL_CLUSTER_STATE: ${ETCD_INITIAL_CLUSTER_STATE:-new}
      ETCD_INITIAL_CLUSTER_TOKEN: patroni-stack
    command: etcd
    ports:
      - "2379:2379"
      - "2380:2380"
    volumes:
      - ./data/etcd:/etcd-data
    networks:
      - pg-net
    healthcheck:
      test: ["CMD-SHELL", "ETCDCTL_API=3 etcdctl --endpoints=http://localhost:2379 endpoint health || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 3
      start_period: 15s
    restart: unless-stopped
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 512M

  patroni:
    image: ${PATRONI_IMAGE:-patroni:v4.1.0.1}
    container_name: patroni
    hostname: patroni${NODE_ID}
    # 覆盖镜像 ENTRYPOINT，否则 command 会变成 patroni.py 的参数，启动脚本不会执行
    entrypoint: ["sh", "-c"]
    env_file:
      - ./patroni/patroni.env
    # 不传 PATRONI_*_CONNECT_ADDRESS，避免合并时被错误 env 覆盖；启动脚本用 patroni.env 的 NODE_IP 重写 yml 再启动
    environment:
      PATRONI_SCOPE: pg-cluster
      PATRONI_NAMESPACE: /service/
      PATRONI_ETCD3_HOSTS: ${NODE1_IP}:2379,${NODE2_IP}:2379,${NODE3_IP}:2379
      ETCD_HOSTS: ${NODE1_IP}:2379,${NODE2_IP}:2379,${NODE3_IP}:2379
    ports:
      - "5432:5432"
      - "8008:8008"
    volumes:
      - ./patroni/patroni.yml:/config/patroni.yml:ro
      - ./patroni/patroni.env:/config/patroni.env:ro
      - ./patroni/init-extensions.sh:/config/init-extensions.sh:ro
      - ./data/pg:/home/postgres/pgdata
    # entrypoint 为 sh -c，command 仅一段脚本（勿再写 sh -c，否则会变成 sh -c "sh" 立即退出）
    command:
      - |
        set -e
        set -a && . /config/patroni.env 2>/dev/null || true && set +a
        [ -n "$${NODE_IP}" ] || { echo "NODE_IP empty in patroni.env"; exit 1; }
        cp /config/patroni.yml /tmp/patroni.yml
        sed -i -e "s|connect_address: .*:8008|connect_address: $${NODE_IP}:8008|" -e "s|connect_address: .*:5432|connect_address: $${NODE_IP}:5432|" /tmp/patroni.yml
        unset PATRONI_POSTGRESQL_CONNECT_ADDRESS PATRONI_RESTAPI_CONNECT_ADDRESS
        exec python3 /patroni.py /tmp/patroni.yml
    depends_on:
      etcd:
        condition: service_healthy
    networks:
      - pg-net
    healthcheck:
      test: ["CMD-SHELL", "curl -sf http://localhost:8008/health || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 3
      start_period: 30s
    restart: unless-stopped
    deploy:
      resources:
        limits:
          cpus: '2'
          memory: 2G

  haproxy:
    image: ${PATRONI_IMAGE:-patroni:v4.1.0.1}
    container_name: haproxy
    entrypoint: []
    command: ["haproxy", "-f", "/usr/local/etc/haproxy/haproxy.cfg"]
    volumes:
      - ./haproxy/haproxy.cfg:/usr/local/etc/haproxy/haproxy.cfg:ro
    ports:
      - "5000:5000"
      - "5001:5001"
      - "8404:8404"
    depends_on:
      patroni:
        condition: service_healthy
    networks:
      - pg-net
    healthcheck:
      test: ["CMD", "haproxy", "-c", "-f", "/usr/local/etc/haproxy/haproxy.cfg"]
      interval: 10s
      timeout: 5s
      retries: 3
    restart: unless-stopped

  # 使用自定义 pgbouncer.ini 时请用默认镜像 edoburu/pgbouncer；若 .env 中 PGBOUNCER_IMAGE=bitnami/pgbouncer 会校验 POSTGRESQL_PASSWORD
  pgbouncer:
    image: ${PGBOUNCER_IMAGE:-edoburu/pgbouncer:v1.24.1-p1}
    container_name: pgbouncer
    environment:
      POSTGRESQL_PASSWORD: ${POSTGRESQL_PASSWORD:-flytrap}
    volumes:
      - ./pgbouncer/pgbouncer.ini:/etc/pgbouncer/pgbouncer.ini:ro
      - ./pgbouncer/userlist.txt:/etc/pgbouncer/userlist.txt:ro
    ports:
      - "6432:6432"
    depends_on:
      haproxy:
        condition: service_healthy
    networks:
      - pg-net
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -h localhost -p 6432 || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 3
      start_period: 10s
    restart: unless-stopped

  keepalived:
    image: osixia/keepalived:stable
    container_name: keepalived
    network_mode: host
    cap_add:
      - NET_ADMIN
      - NET_BROADCAST
      - NET_RAW
    volumes:
      - ./keepalived/keepalived.conf:/etc/keepalived/keepalived.conf:ro
      - ./keepalived/check_haproxy.sh:/etc/keepalived/check_haproxy.sh:ro
    # 覆盖镜像默认的 run 包装脚本，直接执行 keepalived（该镜像 ENTRYPOINT 不接收 -f/--dont-fork 等参数）
    entrypoint: ["keepalived"]
    command: ["-f", "/etc/keepalived/keepalived.conf", "--dont-fork"]
    depends_on:
      - haproxy
    restart: unless-stopped
    profiles:
      - with-vip
